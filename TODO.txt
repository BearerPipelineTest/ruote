
[o] port load26 (requires BlockParticipant)
[o] logger service
[o] test logger
[o] object full_dup
[o] engine#remove_service
[o] :receive or :receive_back for when workitems come back from participant
[o] emit :processes :launch :wfid
[o] emit :processes :terminate :wfid only
[o] arch doc
[o] verbose always on
[o] ev : :participants :register/:unregister
[o] test logger always on for tests (in-memory only)
[o] NullParticipant
[o] NoOpParticipant
[o] rufus-dollar
[o] variables in ProcessStatus (process level only)
[o] ProcessStatus#tree

[o] subprocess binding
[o] subprocess lookup
[o] participant lookup
[o] event : launch_sub

[o] event : :processes, :cancelled ?

[o] concurrence : over_if

[o] pool cleanup

[o] fexp : created_time
[o] ps : launched_time
[o] ps : #tags

[o] wi test (and fix) ${f:xyz}
[o] wi#to_h #from_h
[o] wi.params

[o] self rec for [main] process

[o] fexp.modified_time

[ ] wfid_gen : rufus-mnemo

[ ] file logger service

[ ] fs_error_journal
[ ] fs_error_journal : restart test
[ ] do errors get removed after being replayed ?

[o] cache storage
[o] fs storage

[o] tag (which implies variables)
[o] event : upon setting tag !
[o] event : upon leaving tag
[o] undo
[o] redo
[o] cancel-process (exp)

[o] cancel_process
[o] cancel
[o] on_error
[o] on_cancel

[o] iterator
[o] iterator : break, cancel, ...

[o] cursor
[o] cursor : jump to tag
[o] loop

[o] if
[o] equals
[ ] unset
[ ] concurrent-iterator < concurrence
[ ] save / restore
[ ] when (exploit :var :set event)
[ ] error
[ ] reserve (enhanced ?)

[ ] conditional : rprefix !

[o] stop passing full exp in message, except for expression updates

[x] engine#reload

[o] participants shutdown

[o] stalled [participant] expressions restart (apply/reply ?)
    "re-apply on reload"
    http://groups.google.com/group/openwferu-users/browse_thread/thread/c2aa4b53d1664d45
[ ] auto-participant re-apply

[ ] define without name (__result__)

[x] workitem.__result__ / why, the workitem itself is the result
[ ] smart lookup ? (?)

[o] tracker

[o] sleep
[o] listen
[o] listen wfid="x"
[o] exploded scheduler

[o] persisted tracker


[x] wfid --> piid (stick with the funny old name)

[ ] pooltool.ru

[o] wfidgen.shutdown (close wfidgen.last)

[o] conditional for everybody
[o] timeout for everybody
[ ] Andrew's at for timeouts (Chronic maybe)
[ ] __timeout__ = true ? (wi.fields)

[ ] forget : participant ? subprocess ? everybody

[o] participant : do thread (and do_not_thread)

[o] add test for error replay in participant

[ ] participant dispatch thread throttling ?
[ ] func tests : wire assert_no_errors back in

[o] engine.processes()

[o] kill_process != cancel_process (need a way to not trigger on_cancel)

[ ] pdef.to_dot
[ ] expstorage.to_dot

[o] @in_cancel, @in_error --> @state (active|cancelling|killing)
[ ] tailcall
[ ] subprocesses participants (alias ?)

restart tests :
[o] wait
[o] listen
[ ] when

[o] Jason Allen's check about concurrence

[ ] on_timeout => 'part|sub|error' (idea by hassox)
[x] on_cancel => 'error' NO

[o] event on [un]setting variable

