
[o] port load26 (requires BlockParticipant)
[o] logger service
[o] test logger
[o] object full_dup
[o] engine#remove_service
[o] :receive or :receive_back for when workitems come back from participant
[o] emit :processes :launch :wfid
[o] emit :processes :terminate :wfid only
[o] arch doc
[o] verbose always on
[o] ev : :participants :register/:unregister
[o] test logger always on for tests (in-memory only)
[o] NullParticipant
[o] NoOpParticipant
[o] rufus-dollar
[o] variables in ProcessStatus (process level only)
[o] ProcessStatus#tree
[o] subprocess binding
[o] subprocess lookup
[o] participant lookup
[o] event : launch_sub
[o] event : :processes, :cancelled ?
[o] concurrence : over_if
[o] pool cleanup
[o] fexp : created_time
[o] ps : launched_time
[o] ps : #tags
[o] wi test (and fix) ${f:xyz}
[o] wi#to_h #from_h
[o] wi.params
[o] self rec for [main] process
[o] fexp.modified_time
[o] wfid_gen : rufus-mnemo
[o] fs_error_journal
[o] fs_error_journal : restart test
[o] do errors get removed after being replayed ? yes.
[o] cache storage
[o] fs storage
[o] tag (which implies variables)
[o] event : upon setting tag !
[o] event : upon leaving tag
[o] undo
[o] redo
[o] cancel-process (exp)
[o] cancel_process
[o] cancel
[o] on_error
[o] on_cancel
[o] iterator
[o] iterator : break, cancel, ...
[o] cursor
[o] cursor : jump to tag
[o] loop
[o] if
[o] equals
[o] unset
[o] cursor/loop/iterator : break-if rewind-if
[o] stop passing full exp in message, except for expression updates
[x] engine#reload
[o] participants shutdown
[o] stalled [participant] expressions restart (apply/reply ?)
    "re-apply on reload"
    http://groups.google.com/group/openwferu-users/browse_thread/thread/c2aa4b53d1664d45
[x] workitem.__result__ / why, the workitem itself is the result
[o] tracker
[o] sleep
[o] listen
[o] listen wfid="x"
[o] exploded scheduler
[x] wfid --> piid (stick with the funny old name)
[o] persisted tracker
[o] wfidgen.shutdown (close wfidgen.last)
[o] conditional for everybody
[o] timeout for everybody
[o] __timed_out__ = true ? (wi.fields)
[o] engine.processes()
[o] kill_process != cancel_process (need a way to not trigger on_cancel)
[o] pdef.to_dot (a beginning)
[o] @in_cancel, @in_error --> @state (active|cancelling|killing)
[o] wait
[o] listen
[o] Jason Allen's check about concurrence
[x] on_cancel => 'error' NO
[o] event on [un]setting variable
[o] condition : != ~= >= ....
[o] fs_participant
[o] participant : do thread (and do_not_thread)
[o] add test for error replay in participant
[o] forget : participant ? subprocess ? everybody
[o] Ruote.VERSION = "2.0.0" for Kenneth
[o] on_timeout => 'part|sub' (idea by hassox)
[o] on_timeout => 'error' (idea by hassox)
[o] exp : concurrent-iterator < concurrence
[o] exp : reserve
[o] exp : unset
[o] exp : save
[o] exp : restore (and its set-fields alias)
[o] participant : if EM is present use next_ or defer instead of Thread.new
[o] XML process definitions
[o] remote process definitions
[o] json process definitions
[o] check nested ${f:a.b.c}
[o] test : participant in error timeout (error should cancel timeout)
[o] nested set wi.fields['a.b.0'] = x
[o] nested save wi.fields['a.b.0'] = x
[o] parser.rb : test security check
[o] add Ruote::Launchitem
[o] participant#cancel pass flavour as well nil|:kill|:timeout
[o] BlockParticipant : |workitem, fexp|
[o] listeners
[o] engine.wait_for
[o] func tests : wire assert_no_errors back in
[o] timeout set by participant [implementation]
[o] test for wfids of errors in subprocesses !
[o] Ruote::Exp:: namespace for expressions
[o] exp : apply (ex-eval)
[o] apply : attributes to variables
[o] subprocess : attributes to variables
[o] concurrent_iterator :times => X
[o] iterator defaults to :to_v => 'i'
[o] concurrent_iterator defaults to :to_v => 'i'
[o] set "f:x" => "blah"; set "v:y" => [ 1, 2 ] (defaults to f:)
[o] subprocess :ref => uri
[o] participants : pass the &block under the option :block
[o] concurrence : :over_unless
[x] engine#register_subprocess (replaced by engine#variables)
[x] switch to JSON friendly pers format for flow expressions
[o] switch to JSON friendly pers format for workitems
[o] rewind :ref => 'tag_of_cursor_exp' (direct) :tag oriented.
[o] exp : error
[o] wait 0.500 / wait 60
[x] exp : reval : not needed, participants are here
[o] exp : inc ? if target is array, becomes append (not cons)
[o] exp : dec ? if target is array, then pop (not car)
[o] _if '${f:x} == ${f:y}'
[x] equals : equals "v:v" => "true"  NO => evokes assignment
[x] if : _if "v:v" => "true" ?  NO => evokes assignement
[x] deferred apply technique / not OK, with EM and next_tick / pro
[o] reserve : perhaps it's better to have an atomic get and set variable...
[o] clean up lookup_var/set_var into locate_var/lookup_var/set_var
[x] Sun Hao's up-to-date-tree idea ${f:participant_name} ps#resolved_tree
[o] error : when an error expression is cancelled, should the err get remove 
    from the process status ? yes.
[o] file logger / history service
[o] engine.process_history(wfid)
[o] add_branch :times/:branches
[o] cursor : :break_if / :break_unless
[o] exp : when (exploit :var :set event, or frequency)
[o] when : restart test
[o] when : cron frequency
[o] let listeners accept launchitems
[o] exp : cron
[o] exp : every
[o] write rt test for 'timeout'
[o] undo exp : alias to 'cancel'

[ ] exp : exp (restricted form of eval ?)
[ ] exp : case (is it necessary ?)
[ ] exp : filter
[ ] exp : filter-definition
[x] exp : lose ?
[x] exp : parameter
[ ] exp : log

[ ] exp : defined (not really necessary)
[ ] exp : quote (not really necessary)
[ ] exp : field / attribute (not really necessary)
[ ] exp : variable (not really necessary)

[ ] exp : step (jump to cursor tag ?)

[ ] conditional : rprefix ! ${r:x} is perhaps sufficient

[ ] auto-participant re-apply

[ ] define without name (__result__)

[ ] pooltool.ru

[ ] Andrew's at for timeouts (Chronic maybe)

[ ] participant dispatch thread throttling ?

[ ] expstorage.to_dot

[ ] tailcall
[ ] subprocesses participants (alias ?)

[ ] __command__ + tag (rewind that cursor there, not the current one)

[ ] beanstalk [as a] workqueue ?

[ ] recursion : should cope with modified trees 'main' => :tree ??

[ ] user3 :rif => "!wi.fields['approvers'].include?('user3')" : 'in' operator

[ ] set :var => 'y' { '2342342' }

[ ] pause engine
[ ] pause process instance

[ ] file/fs_listener [example] ?

[ ] tree.to_xml (require builder ?)
[ ] tree.to_rb

[ ] concurrence / concurrent_iterator : merge plugin ?
    use participant for that ?

[ ] restore : implement merge strategies

[ ] one file, no multi-process, persistence ?

[ ] apply : ruby or xml (instead of just ast) ?

[ ] FsParticipant : what about #first and #all a la dm ?

[ ] unify ruote/util/json and ruote/util/serializer

[ ] jash : Time and DateTime and co ?

[ ] history.to_tree ?

[ ] Ruote.process_definition ... Ruote.method_missing or sequence ?

[ ] concurrence / concurrent_iterator : merge_type => 'discard' / 'ignore'
    keep track of the first "process sub id" ?

[ ] "switch off" for the ticket mecha

[ ] @children diff/undiff idea ?

[ ] write doc about engine options (multi-process !)
[ ] _if '${f:x} == ${f:y} || ${f:x} == ${f:z}'

[ ] document the dollar notation / substitution / extrapolation

[ ] condition : "${f:x} [is] empty" / this one is hard

[ ] ruote/exp/fe_set.rb:147: warning: already initialized constant PREFIX_REGEX

[ ] implement kill_process! (kill_expression! ?)

[ ] engine.force_reply_to_parent(fei) ?

[ ] break fs_history, prepare for dm_history

[ ] :on_timeout => :rewind (break, jump to x)...
[ ] rewind 'x' where x is a tagname (command x)

[ ] repeat : have a counter in a variable (:to => x maybe) (subprocessid ?)

[ ] when : add test for cancelling when child has been triggered / is running
[x] listen : should it forget its triggered children ? yes

[ ] engine.cancel_forgotten_children(wfid) ?

[ ] run full tests at low load with --dm

[ ] port subprocess on_cancel test from ruote 0.9 http://groups.google.com/group/openwferu-users/t/75f02bdadf7b93eb

[ ] double-check on_cancel rewrite (ft_1_process_status)

[ ] clean up persists present in #apply
[ ] listen : to errors

[ ] case exp : smarter one ?
[ ] remove abort_on_exception=true
[ ] timeout :at and :after
[o] limit the number of msgs returned
[ ] issue with :unless => '${f:index} == 2000'
[ ] spare 1 get_msg by caching msg (but keep 'deleting')
[ ] verify get_last/get_raw logic, no + 0.0001...
[ ] add_branches : pass message to concurrent_iterator
    like a command expression
[ ] [un]set_var : via message ? should be ok like that... Not much traffic there

